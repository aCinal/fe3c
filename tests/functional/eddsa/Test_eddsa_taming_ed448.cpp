#include <CppUTest/TestHarness.h>
#include <fe3c/eddsa.h>

TEST_GROUP(EDDSA_TAMING_ED448) {

    /* Test vectors inspired by the paper "Taming the many EdDSAs" by Chalkias et. al. (DOI: 10.1007/978-3-030-64357-7_4)
     * and adapted to the curve Ed448. Notation corresponds to the notation used in the paper as well as in RFC 8032,
     * i.e. S is the response scalar, A is the public key, R is the commitment, h = H(R||A||M) is the hash output and B
     * is the group generator (basepoint). Conditions for each test vector are presented below. */
};

TEST(EDDSA_TAMING_ED448, Test0) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        S = 0
     *          A's order:        small
     *          R's order:        small
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\xac\xdf\x0f\xd8\x73\xf7\x0c\x12" \
        "\xfa\x23\x2c\xcf\xfb\x59\x51\x56" \
        "\xcd\xc6\x01\xfe\xcf\xc8\x13\xdb" \
        "\x3e\xc2\xfe\x66\x84\x1a\xbf\xaa";
    const u8 pub_key[] = \
        "\xfe\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xfe\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\x00";
    const u8 signature[] = \
        "\xfe\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xfe\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x00\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Fail the vector because of small order points */
    CHECK_EQUAL(0, verified);
}

TEST(EDDSA_TAMING_ED448, Test1) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        0 < S < L
     *          A's order:        small
     *          R's order:        mixed
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\x9b\xd9\xf4\x4f\x4d\xcc\x75\xbd" \
        "\x53\x1b\x56\xb2\xcd\x28\x0b\x0b" \
        "\xb3\x8f\xc1\xcd\x6d\x12\x30\xe1" \
        "\x48\x61\xd8\x61\xde\x09\x2e\x79";
    const u8 pub_key[] = \
        "\xfe\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xfe\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\x00";
    const u8 signature[] = \
        "\x7d\x48\xf1\xbd\xf9\xca\xb7\x52" \
        "\xa7\x69\x94\x01\xf5\xc1\x5f\x4b" \
        "\x73\xe7\xd7\x2e\x51\x99\xf7\x6f" \
        "\x07\x88\x2c\xb0\x64\x63\x5d\xff" \
        "\xba\xfa\x52\x82\xd5\x49\x7a\x96" \
        "\x6e\x60\x49\xc5\x57\x3c\xcf\xce" \
        "\xfb\x66\x60\x98\xb0\xb4\xa2\x48" \
        "\x80\x4a\x1c\xe6\x86\xac\x0a\xb8" \
        "\x26\xbe\xfd\x2a\xea\x59\xfd\xd4" \
        "\xd7\x95\xa9\xba\x70\xea\x29\xb9" \
        "\x89\x06\x39\xf2\x66\x17\x46\x5b" \
        "\x52\x9e\x81\x67\x81\x4d\xb1\xe6" \
        "\x5e\x07\x15\x81\xc2\x10\x5d\x62" \
        "\xa9\x6f\xf0\xee\xb1\x16\x79\x79" \
        "\x2a\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Fail the vector because of small order public key */
    CHECK_EQUAL(0, verified);
}

TEST(EDDSA_TAMING_ED448, Test2) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        0 < S < L
     *          A's order:        mixed
     *          R's order:        small
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\xae\xbf\x3f\x26\x01\xa0\xc8\xc5" \
        "\xd3\x9c\xc7\xd8\x91\x16\x42\xf7" \
        "\x40\xb7\x81\x68\x21\x8d\xa8\x47" \
        "\x17\x72\xb3\x5f\x9d\x35\xb9\xab";
    const u8 pub_key[] = \
        "\x09\x82\x6e\xec\xa9\x21\x06\x85" \
        "\x77\x64\x77\x57\x9b\x4c\xfd\xeb" \
        "\xec\x6c\x39\x73\x9a\x00\x92\xc4" \
        "\x65\x1f\x01\xb1\xa4\xfb\x47\xe5" \
        "\x0b\x68\x35\x63\xfc\x40\xcb\x73" \
        "\x22\x15\xb5\x0c\xc0\x16\x01\xc9" \
        "\x34\x4e\xd2\x66\xbf\x0d\x7f\x11" \
        "\x80";
    const u8 signature[] = \
        "\xfe\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xfe\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\xff\xff\xff\xff\xff\xff\xff\xff" \
        "\x00\xbc\x44\xaa\xbb\x6a\x8b\xe9" \
        "\x0b\x81\xab\x6f\x87\x2e\x49\xec" \
        "\x7c\x53\xfb\x9c\x68\x8b\x78\xe6" \
        "\xc1\xcf\x12\xca\x20\x02\x6f\xfa" \
        "\x3f\xd3\x3f\x29\xed\x83\x92\xc9" \
        "\x0f\xb3\xfe\x19\x5c\x54\x39\xa9" \
        "\x50\x97\xd1\x09\x44\xc6\x9e\xc8" \
        "\x23\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    CHECK_EQUAL(0, verified);
}

TEST(EDDSA_TAMING_ED448, Test3) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        0 < S < L
     *          A's order:        mixed
     *          R's order:        mixed
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\x9b\xd9\xf4\x4f\x4d\xcc\x75\xbd" \
        "\x53\x1b\x56\xb2\xcd\x28\x0b\x0b" \
        "\xb3\x8f\xc1\xcd\x6d\x12\x30\xe1" \
        "\x48\x61\xd8\x61\xde\x09\x2e\x79";
    const u8 pub_key[] = \
        "\x78\x3b\x75\xc2\x8b\x91\x82\xc0" \
        "\x2b\xef\xc1\x9c\xab\xe9\x5a\x08" \
        "\x9f\xed\xe0\x5b\xf8\x75\x73\xfb" \
        "\xf4\x09\x63\xd8\x7e\x59\x8d\xa0" \
        "\x1b\x6f\x50\x7a\x82\xe3\xf9\x6b" \
        "\xe6\x07\xb8\x89\x82\x29\x09\x64" \
        "\xfa\xfe\x08\xe9\x9f\x98\x03\x97" \
        "\x80";
    const u8 signature[] = \
        "\xf0\x97\x06\x9f\xf1\xba\xf4\x2c" \
        "\x07\x14\x6c\x40\x5e\x08\xf9\xc4" \
        "\xb6\x61\x4a\x3a\x22\x3b\x2b\xc5" \
        "\xe3\xcd\xbc\x15\xc6\xe9\x3e\x5c" \
        "\x1b\xd8\x77\x5b\x1a\x9d\xb2\x0e" \
        "\x04\xfc\x60\xb6\xa1\x8e\xca\x68" \
        "\x66\x43\x4d\x64\xb4\x08\xda\xd8" \
        "\x80\x80\x40\x2f\x23\x48\xa2\x68" \
        "\x61\x36\x62\x5e\x7f\xd0\xe9\xd7" \
        "\x14\x26\x38\xfb\xea\xe3\xb4\x93" \
        "\x51\x22\xe2\x04\xa7\x0c\x05\x2f" \
        "\xb8\xaa\xe8\x88\x78\xb3\x05\xcf" \
        "\x2d\x34\x29\x26\x57\xd6\x94\xf1" \
        "\x6a\xe9\x8c\xf0\xeb\xe4\xc7\xf3" \
        "\x27\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Accept mixed-order points */
    CHECK_EQUAL(1, verified);
}

TEST(EDDSA_TAMING_ED448, Test4) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        0 < S < L
     *          A's order:        mixed
     *          R's order:        mixed
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        nok
     */

    const u8 message[] = \
        "\xe4\x7d\x62\xc6\x3f\x83\x0d\xc7" \
        "\xa6\x85\x1a\x0b\x1f\x33\xae\x4b" \
        "\xb2\xf5\x07\xfb\x6c\xff\xec\x40" \
        "\x11\xea\xcc\xd5\x5b\x53\xf5\x6c";
    const u8 pub_key[] = \
        "\x80\x5c\x15\x5e\x5a\x74\xb5\xe5" \
        "\xa9\xa1\x4f\xfe\x03\xbf\xa0\x5d" \
        "\xda\x01\x57\x9d\x3b\xfd\x17\x57" \
        "\x8f\x13\x81\xb9\xc2\xa6\x29\xea" \
        "\x6a\xfe\x8b\xc6\x7d\x4a\x26\xd8" \
        "\x3d\x0f\x4d\x7a\xba\x22\xd5\xcd" \
        "\x2f\x9f\xf8\x1e\xc0\x72\x2d\x44" \
        "\x80";
    const u8 signature[] = \
        "\xa3\xc1\x49\x5d\xe3\x33\x32\x9c" \
        "\x67\x53\xef\xb9\xb3\x48\x81\x5a" \
        "\x79\x9c\x4f\x52\x7b\xb8\x0a\xfd" \
        "\xb9\x48\xe2\x4d\xce\x7a\x26\x76" \
        "\x09\x8c\x8c\x36\x75\x02\x6e\x4c" \
        "\xcc\x7d\xa7\x9e\xc8\x0a\xe4\xb6" \
        "\x65\xd0\x9d\x61\x1d\x90\xac\xdd" \
        "\x80\x13\x79\xcb\x53\x31\xeb\xc7" \
        "\xd4\xab\xc7\x06\xd6\xf3\xaf\x96" \
        "\x82\x06\xd5\x74\x2c\x18\xba\xca" \
        "\x9a\xae\x27\xbc\xe2\x40\xd7\xb3" \
        "\xc9\x70\xf6\x72\x7f\xd9\x23\x9f" \
        "\xf5\xc9\x7b\x3e\x19\x14\x2a\x69" \
        "\x32\x30\xb3\x76\xfa\x86\x3f\x04" \
        "\x27\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Because of the 4-isogeny we do cofactored verification and so
     * we expect success here */
    CHECK_EQUAL(1, verified);
}

TEST(EDDSA_TAMING_ED448, Test5) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        0 < S < L
     *          A's order:        mixed
     *          R's order:        L
     * 4(SB) = 4R + 4(hA):        ok (unless 4h is prereduced modulo L)
     *        SB = R + hA:        nok
     */

    const u8 message[] = \
        "\xe4\x7d\x62\xc6\x3f\x83\x0d\xc7" \
        "\xa6\x85\x1a\x0b\x1f\x33\xae\x4b" \
        "\xb2\xf5\x07\xfb\x6c\xff\xec\x40" \
        "\x11\xea\xcc\xd5\x5b\x53\xf5\x6c";
    const u8 pub_key[] = \
        "\xae\x89\x19\x51\x00\xe8\x48\xdc" \
        "\x30\xc4\x06\x27\xaa\x6c\xc8\x41" \
        "\xf3\xe3\x98\x80\xdc\xca\x13\x21" \
        "\x69\x5c\xa1\xfc\xd1\xc6\xcd\x19" \
        "\xd6\xb7\x96\x02\x70\x0b\xfc\x45" \
        "\x9e\x12\x91\xfd\xe5\x49\x3c\x3e" \
        "\x99\x68\x0a\xc8\xaf\xd9\x9c\x6c" \
        "\x00";
    const u8 signature[] = \
        "\x53\x19\x63\x0e\x69\x5a\xa7\x33" \
        "\x35\xf1\x80\x19\x5e\x24\x71\xba" \
        "\x1e\xab\xde\xb9\x63\x89\x7d\x91" \
        "\x7e\x70\x16\xc0\xf1\x0a\x4e\x3f" \
        "\xdb\x96\x37\xaa\x40\x09\x6c\x71" \
        "\x36\x6c\x83\x27\xd4\x47\xa5\x34" \
        "\x6d\x3a\x75\x55\x48\xb1\x78\x37" \
        "\x80\xb8\x99\x1b\xfc\xce\xf7\x12" \
        "\x87\x29\xe2\x84\xce\x70\x85\xe5" \
        "\xd6\xbd\x3e\xf3\x14\xa8\x31\x65" \
        "\x45\x42\x62\xb3\x14\xc8\xd8\xc9" \
        "\x3d\xb4\x14\x49\x98\x10\x96\xbe" \
        "\x24\x42\x76\x9a\x90\x6c\xf6\xea" \
        "\xdc\xbf\xb6\xcc\x3a\x4d\x9e\xc5" \
        "\x0f\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Because of the 4-isogeny we do cofactored verification and so
     * we expect success here */
    CHECK_EQUAL(1, verified);
}

TEST(EDDSA_TAMING_ED448, Test6) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        S > L
     *          A's order:        L
     *          R's order:        L
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\x85\xe2\x41\xa0\x7d\x14\x8b\x41" \
        "\xe4\x7d\x62\xc6\x3f\x83\x0d\xc7" \
        "\xa6\x85\x1a\x0b\x1f\x33\xae\x4b" \
        "\xb2\xf5\x07\xfb\x6c\xff\xec\x40";
    const u8 pub_key[] = \
        "\x7f\xcf\x47\xd3\xd3\x34\x84\x5c" \
        "\x2a\x23\x7e\x1a\xcb\x1e\x66\x7e" \
        "\xae\x98\x88\x7d\x22\x2a\x5d\xf8" \
        "\x3c\x1b\x85\xfd\x9e\x1e\xc3\xfe" \
        "\xea\x86\xf1\x16\xfd\xff\x20\xda" \
        "\x79\x54\x8c\x8c\x40\xc2\x68\xb6" \
        "\xe0\xcb\x6f\x15\x27\xc5\x40\x9b" \
        "\x00";
    const u8 signature[] = \
        "\x8b\x4b\x94\xcc\x55\x93\xca\xb5" \
        "\x38\xa8\x7a\xb4\x93\x67\x21\x42" \
        "\x6b\xec\xc1\xf7\x6d\x80\x16\xfe" \
        "\xc2\x06\x08\x39\xb0\x41\xa2\xe9" \
        "\xa5\x85\x4e\x1a\xe0\x51\x41\x80" \
        "\xab\xf7\xc4\xbe\xa4\x5f\xb8\x3c" \
        "\x6c\x43\x9d\xc5\x81\x13\x42\x93" \
        "\x00\xb7\xef\xea\xd0\x0d\x96\xd7" \
        "\x25\xb2\x8c\x17\x20\x01\xda\x8e" \
        "\xd9\x70\x5a\xec\xe2\xbb\x8e\x20" \
        "\xf0\x74\x5b\xc9\x7a\x00\x5f\x9f" \
        "\x45\x95\xed\x0a\x6f\x50\xb6\xe4" \
        "\xb8\x2d\xbe\x36\x07\x0c\x95\x16" \
        "\x9e\x87\x1e\x23\xdc\x13\xc0\x14" \
        "\x71\x00";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Fail the vector because of non-canonical response scalar */
    CHECK_EQUAL(0, verified);
}

TEST(EDDSA_TAMING_ED448, Test7) {

    /* Conditions satisified by the test vector:
     *
     *                  S:        S >> L
     *          A's order:        L
     *          R's order:        L
     * 4(SB) = 4R + 4(hA):        ok
     *        SB = R + hA:        ok
     */

    const u8 message[] = \
        "\x85\xe2\x41\xa0\x7d\x14\x8b\x41" \
        "\xe4\x7d\x62\xc6\x3f\x83\x0d\xc7" \
        "\xa6\x85\x1a\x0b\x1f\x33\xae\x4b" \
        "\xb2\xf5\x07\xfb\x6c\xff\xec\x40";
    const u8 pub_key[] = \
        "\x25\xdb\x4b\x99\xa1\x23\x1b\x25" \
        "\x6d\xf9\xb5\xf7\x77\x2b\x23\x3b" \
        "\x3a\xac\x87\x59\x9f\xcb\x8a\x66" \
        "\x68\xd3\x6d\x30\x4a\xe8\x7b\x93" \
        "\xed\x90\x0b\x64\xa4\x4c\x8b\x14" \
        "\xf0\x94\x9e\x04\x8c\xfa\x99\x5d" \
        "\xd2\x53\x91\x05\xff\xac\x9e\x8f" \
        "\x80";
    const u8 signature[] = \
        "\x74\xba\xcf\x10\x0f\xdc\x5a\xe7" \
        "\x19\x17\xb8\x1b\xca\xa7\x4a\x55" \
        "\xbb\x85\xb9\x13\xd2\xea\xc2\x41" \
        "\x30\xc5\xd5\xd8\x33\xa2\x06\xb7" \
        "\xaf\x69\xa5\x89\x90\x4c\x4d\x65" \
        "\x32\xfb\x80\xb4\x42\x1f\x81\xad" \
        "\xfd\xe9\xdc\xf5\xa9\x0f\x61\x26" \
        "\x00\xb2\xf7\xb5\x8e\x43\x44\xe6" \
        "\x56\x39\xd6\x79\x8c\x8a\x2c\xd8" \
        "\x31\x4d\x79\x59\xa8\xe0\xc3\xce" \
        "\x4f\x43\xb4\x59\x7e\xc9\x57\xb2" \
        "\x41\xab\x2d\x7d\x32\xd2\xe7\xe7" \
        "\x4c\xc9\xeb\xcd\xc6\xb2\x92\x3b" \
        "\x13\xf7\x90\x19\x2f\x03\xbf\xfe" \
        "\x4b\x08";

    eddsa_verify_request req = {
        .signature = signature,
        .message = message,
        .public_key = pub_key,
        .message_length = sizeof(message) - 1,
        .curve_id = EDDSA_CURVE_ED448,
    };
    int verified = eddsa_verify(&req);
    /* Fail the vector because of non-canonical response scalar */
    CHECK_EQUAL(0, verified);
}
