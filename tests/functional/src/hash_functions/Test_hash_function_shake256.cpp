#include <functional_tests.h>
#include <hash_functions/hash_functions.h>
#include <string.h>
#include <algorithm>

#define HASH_OUTPUT_SIZE_IN_BYTES  ( 114 )
#define APPROPRIATE_IOV_LEN(iov)   (iov).iov_len = strlen(static_cast<const char *>((iov).iov_base));

#if FE3C_FUNCTIONAL_TESTS_HOST
TEST_GROUP(HASH_FUNCTION_SHAKE256) {

};
#endif /* FE3C_FUNCTIONAL_TESTS_HOST */

FE3C_TEST(HASH_FUNCTION_SHAKE256, EmptyIovec) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\x46\xb9\xdd\x2b\x0b\xa8\x8d\x13\x23\x3b\x3f\xeb\x74\x3e\xeb\x24" \
        "\x3f\xcd\x52\xea\x62\xb8\x1b\x82\xb5\x0c\x27\x64\x6e\xd5\x76\x2f" \
        "\xd7\x5d\xc4\xdd\xd8\xc0\xf2\x00\xcb\x05\x01\x9d\x67\xb5\x92\xf6" \
        "\xfc\x82\x1c\x49\x47\x9a\xb4\x86\x40\x29\x2e\xac\xb3\xb7\xc4\xbe" \
        "\x14\x1e\x96\x61\x6f\xb1\x39\x57\x69\x2c\xc7\xed\xd0\xb4\x5a\xe3" \
        "\xdc\x07\x22\x3c\x8e\x92\x93\x7b\xef\x84\xbc\x0e\xab\x86\x28\x53" \
        "\x34\x9e\xc7\x55\x46\xf5\x8f\xb7\xc2\x77\x5c\x38\x46\x2c\x50\x10" \
        "\xd8\x46";

    hash_shake256(output, nullptr, 0);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}

FE3C_TEST(HASH_FUNCTION_SHAKE256, EmptyString) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\x46\xb9\xdd\x2b\x0b\xa8\x8d\x13\x23\x3b\x3f\xeb\x74\x3e\xeb\x24" \
        "\x3f\xcd\x52\xea\x62\xb8\x1b\x82\xb5\x0c\x27\x64\x6e\xd5\x76\x2f" \
        "\xd7\x5d\xc4\xdd\xd8\xc0\xf2\x00\xcb\x05\x01\x9d\x67\xb5\x92\xf6" \
        "\xfc\x82\x1c\x49\x47\x9a\xb4\x86\x40\x29\x2e\xac\xb3\xb7\xc4\xbe" \
        "\x14\x1e\x96\x61\x6f\xb1\x39\x57\x69\x2c\xc7\xed\xd0\xb4\x5a\xe3" \
        "\xdc\x07\x22\x3c\x8e\x92\x93\x7b\xef\x84\xbc\x0e\xab\x86\x28\x53" \
        "\x34\x9e\xc7\x55\x46\xf5\x8f\xb7\xc2\x77\x5c\x38\x46\x2c\x50\x10" \
        "\xd8\x46";

    struct iovec iov = {
        .iov_base = nullptr,
        .iov_len = 0
    };
    hash_shake256(output, &iov, 1);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}

FE3C_TEST(HASH_FUNCTION_SHAKE256, SingleMessageOfLength128) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\xd2\xa1\x15\xf5\x11\x36\x78\x85\x67\x97\x1f\x7a\x5a\xfc\x6a\xef" \
        "\x12\xb6\x12\xa1\x2d\x11\x3d\x8e\x40\x4f\xd5\x6b\x26\x53\x8e\xa4" \
        "\xc1\xa8\xbb\xa2\x6c\xf2\x28\x44\x0d\x29\x52\x9a\x12\x48\x55\x79" \
        "\x9a\xea\x26\x9a\x79\xff\xbb\xd4\x8a\x2b\xfc\x9c\x60\xcf\x9a\x89" \
        "\x1b\x78\xb6\x0e\x68\x2e\xe5\x44\x6e\x75\xf3\x34\xaf\xd9\x02\x56" \
        "\x83\xa4\x8b\x87\x5d\x7d\xcf\x79\x37\x6a\x7e\xd2\x64\x4f\x37\x25" \
        "\xd7\x50\xae\x16\x6a\x41\xd6\x96\x10\x2e\xc2\xa0\x0c\x9a\xf6\xc7" \
        "\x04\x14";


    u8 message[128];
    std::fill(message, message + 128, 0xAA);
    struct iovec iov = {
        .iov_base = message,
        .iov_len = sizeof(message)
    };
    hash_shake256(output, &iov, 1);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}

FE3C_TEST(HASH_FUNCTION_SHAKE256, HelloWorld) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\x20\x74\x0b\x4c\x7a\x79\x97\x76\x5e\x9c\xc2\x54\xb4\x4a\x15\x89" \
        "\xe6\x08\x49\xbe\x0f\xe7\x0b\x68\xa6\xfb\x73\x24\x15\xed\xaa\x13" \
        "\x3b\xb6\xeb\x78\x25\xff\xa5\x31\xd8\x4e\xf9\x4c\x2a\x83\x09\xc2" \
        "\xa3\x42\xb0\x53\x56\xf1\x10\xc2\xd4\x6e\x90\xc9\x28\xe3\xec\xd6" \
        "\x83\x35\x00\xba\xef\xa9\x9a\xc4\xdf\x6b\xd8\x4b\xd6\x95\x4a\x6f" \
        "\x3c\x73\x24\x28\x8d\xed\x24\x17\x61\x59\xe2\xc6\x08\xf8\x3b\x6b" \
        "\xb4\xce\x07\xe3\x9a\x18\x6a\x6c\xa8\x16\x73\x7c\x92\x8e\x5a\xac" \
        "\x09\x81";

    struct iovec iov;
    iov.iov_base = "Hello world";
    APPROPRIATE_IOV_LEN(iov);
    hash_shake256(output, &iov, 1);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}

FE3C_TEST(HASH_FUNCTION_SHAKE256, GatherIoTest) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\x2f\xa2\x63\xfa\xef\x62\xcc\xa3\xf7\x84\xf2\x0e\xe0\xb1\xed\x6e" \
        "\x65\xc1\xa8\xa5\xb1\x84\xac\xa6\x5c\xf5\x7b\x2a\x36\xc2\xed\x2c" \
        "\xfe\xb1\x85\x29\xa1\x3c\xd7\xcc\x8b\x6a\x5f\x3c\x88\xdb\xa5\x48" \
        "\x6c\x85\x75\xac\xfb\x37\x9a\xfa\xff\x03\x80\xd8\x9f\x60\xd0\x38" \
        "\x14\x4e\x14\x11\xf8\xe8\x7b\xf0\x98\x20\x2f\xc2\xc5\x87\x6a\xab" \
        "\x05\x3d\xa5\xe4\xb1\x6f\x3d\xfc\xb1\x60\xd6\xce\x36\xbd\xbb\x7f" \
        "\x6c\x99\xbc\x69\x15\x14\x3d\xf4\x66\xc9\x10\x39\xd8\x1c\xf2\x60" \
        "\xb7\x71";

    struct iovec iov[3];
    iov[0].iov_base = "From space it seems an abstraction.";
    APPROPRIATE_IOV_LEN(iov[0]);
    iov[1].iov_base = "A magician's trick on a darkened stage.";
    APPROPRIATE_IOV_LEN(iov[1]);
    iov[2].iov_base = "And from this distance one might never imagine that it is alive.";
    APPROPRIATE_IOV_LEN(iov[2]);
    hash_shake256(output, iov, 3);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}

FE3C_TEST(HASH_FUNCTION_SHAKE256, BufferSkippingTest) {

    u8 output[HASH_OUTPUT_SIZE_IN_BYTES];
    const u8 expected_output[] = \
        "\x9a\xdb\xef\x37\x16\x14\x54\xa0\x26\xd9\xb4\x9e\x23\x18\xd7\xd2" \
        "\x38\x7a\xb1\x4a\x67\xe0\x02\x28\x78\x37\x76\xb4\x25\x23\xed\xec" \
        "\x8d\xf1\x44\x6e\xc3\xfd\x22\xde\x6c\x1d\x33\xe9\xd4\xd5\x78\x87" \
        "\x4f\x5e\xec\x28\xe1\x1d\xd2\x47\x85\x25\xb1\xa9\x75\xac\xa0\xab" \
        "\xb8\x01\x50\x80\xa2\x20\x48\x01\xdd\xbf\x5c\xf1\xd1\x6d\x46\xb8" \
        "\x87\x9b\xe0\x32\x6a\x7c\xfb\x43\x41\x89\x0a\xec\x40\x7f\x9b\xd5" \
        "\x41\x6e\xfc\x3f\x28\xec\xd0\x45\xbd\x36\x90\x49\x38\x88\x18\xe1" \
        "\x55\x17";

    struct iovec iov[3];
    iov[0].iov_base = "What are they doing in the Hyacinth house?";
    APPROPRIATE_IOV_LEN(iov[0]);
    iov[1].iov_base = "What are they doing in the Hyacinth house?";
    /* Expect the second buffer to be skipped */
    iov[1].iov_len = 0;
    iov[2].iov_base = "To please the lions, yeah, this day.";
    APPROPRIATE_IOV_LEN(iov[2]);
    hash_shake256(output, iov, 3);

    FAIL_IF_MEMCMP(expected_output, output, HASH_OUTPUT_SIZE_IN_BYTES);
}
